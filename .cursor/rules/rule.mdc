---
alwaysApply: true
---
1.	Verify Environment Compatibility
o	Ensure the new device‚Äôs runtime environment (e.g., Node.js, Python, PHP version) matches the original device‚Äôs setup.
o	Install all required dependencies and libraries, ensuring version compatibility with the original system.
o	Check environment variables and update any device-specific configurations (e.g., file paths, database URLs).
o	Use Cursor AI to scan for environment mismatches by analyzing dependency files (e.g., package.json, requirements.txt).
2.	Validate Code Integrity
o	Confirm all code files were transferred correctly using checksums or file comparison tools.
o	Use Cursor AI to scan the codebase for syntax errors, missing files, or hardcoded paths that need updating.
o	Ensure no files are corrupted or incomplete before running the system.
3.	Test Database Connectivity
o	Verify database connection settings (e.g., host, port, credentials) are correct for the new device.
o	Test connectivity with a simple query (e.g., SELECT 1) to ensure the system can access the synced database.
o	Avoid modifying the database schema or data unless explicitly required and validated.
4.	Use a Safe Testing Environment
o	Set up a local or staging environment on the new device to test the system before production deployment.
o	Use Cursor AI to run isolated tests on critical functions or endpoints to identify issues without affecting the live system.
o	Only deploy to production after all tests pass in the safe environment.
5.	Backup Code and Database
o	Create a full backup of the code files and database before making any changes, even though the database is synced.
o	Store backups securely to allow rollback if issues arise.
o	Use Cursor AI to verify backup integrity if possible.
6.	Monitor and Log Issues
o	Enable detailed logging to capture runtime errors or warnings on the new device.
o	Use Cursor AI to analyze logs and error messages for quick issue identification.
o	Address errors incrementally, starting with critical issues (e.g., database connection failures).
7.	Review AI-Suggested Changes
o	Carefully review Cursor AI‚Äôs suggested code changes before applying them to avoid unintended side effects.
o	Test AI-generated code in isolation (e.g., sandbox environment) to ensure it aligns with system requirements.
o	Avoid applying AI suggestions to critical files (e.g., database logic) without manual review.
Cursor AI Coding Rules (Updated for System Fix)
These rules adapt your existing Cursor AI coding standards to the system fix context, ensuring clean, scalable, and debuggable code.
1.	üîç Always Log Errors Clearly
o	Include console.error() in every try-catch or error-prone logic, specifying:
ÔÇß	Function name
ÔÇß	Error message
ÔÇß	Stack trace
o	Example:
console.error("[connectToDatabase] Error:", error.message, error.stack);
o	When fixing system issues, log any environment or transfer-related errors (e.g., missing dependencies, file path issues).
2.	üß† Comment Key Functions Clearly
o	Every function must have a comment describing:
ÔÇß	Purpose
ÔÇß	Parameters
ÔÇß	Return value (if applicable)
o	Example:
o	/**
o	 * Connects to the synced database and verifies connection.
o	 * @param {string} dbUrl - The database connection URL.
o	 * @returns {Promise<boolean>} - True if connection is successful, false otherwise.
o	 */
async function connectToDatabase(dbUrl) { ... }
o	Add comments for any new or modified functions during the fix process to document changes.
3.	‚úÖ Always Handle Promises Properly
o	Use try-catch for async/await to handle errors gracefully.
o	Include .catch() for .then() chains.
o	Example:
o	async function fetchData() {
o	  try {
o	    const data = await apiCall();
o	    return data;
o	  } catch (error) {
o	    console.error("[fetchData] Error:", error.message, error.stack);
o	    throw error;
o	  }
}
o	Ensure database or API calls during system fixes are wrapped in proper error handling.
4.	üö´ No TODOs or Unfinished Code
o	Avoid // TODO comments in final files. Use // REQUIRES IMPLEMENTATION: <description> for pending logic.
o	Example:
// REQUIRES IMPLEMENTATION: Add logic to handle database reconnection on failure.
o	Resolve any existing TODOs related to the system transfer before deployment.
5.	üõ°Ô∏è Use Safe Defaults and Fallbacks
o	Check for null/undefined using optional chaining or fallback values.
o	Example:
const dbHost = config?.database?.host || "localhost";
o	When fixing system issues, ensure fallback values are set for any missing configurations on the new device.
6.	üîÅ DRY Principle (Don't Repeat Yourself)
o	Refactor repeated logic into reusable helper functions or components.
o	Example:
o	/**
o	 * Validates configuration settings for the system.
o	 * @param {Object} config - The configuration object.
o	 * @returns {boolean} - True if valid, false otherwise.
o	 */
function validateConfig(config) { ... }
o	Use Cursor AI to identify and refactor duplicated code during the fix process.
7.	üìÅ Respect File & Folder Structure
o	Maintain the existing folder structure (e.g., /components, /utils, /services).
o	Use camelCase for variables/functions and PascalCase for components.
o	When adding new files during fixes, place them in appropriate folders and use consistent naming.
8.	üßæ Add Header Comment in Every File
o	Include a header comment in each file with the file name and purpose.
o	Example:
o	// File: databaseService.js
// Description: Manages database connections and queries for the system.
o	Update headers in modified files to reflect any changes made during the fix.
9.	üìå Optional (if applicable to project)
o	Enforce strict typing if using TypeScript for any new or modified code.
o	Follow ESLint and Prettier standards for code formatting, using Cursor AI to auto-format files.
o	Auto-generate types/interfaces for API responses if integrating with the synced database.
o	Example:
o	interface User {
o	  id: string;
o	  name: string;
}
Additional Guidelines for System Fix
10.	Check Configuration Files
o	Review configuration files (e.g., .env, config.json) for device-specific settings that need updating.
o	Use Cursor AI to search for hardcoded values or sensitive data that may cause issues on the new device.
o	Example:
o	// File: config.js
o	// Description: System configuration settings.
o	const config = {
o	  dbUrl: process.env.DB_URL || "mongodb://localhost:27017",
};
11.	Test Incrementally
o	Test core functionality (e.g., database queries, API endpoints) before testing the full system.
o	Use Cursor AI to generate unit tests or simulate user interactions to validate fixes.
o	Example:
o	/**
o	 * Tests database connection.
o	 * @returns {Promise<boolean>} - True if connection is successful.
o	 */
async function testDbConnection() { ... }
12.	Document Changes
o	Log all changes made during the fix process in a separate changelog file or comments.
o	Use Cursor AI to generate documentation for modified code to ensure clarity. encha
13.	Avoid Database Modifications
o	Do not alter the database schema or data unless absolutely necessary, as it is already in sync.
o	If changes are needed, create a backup and validate changes in a test environment first.
14.	Validate with Stakeholders
o	After applying fixes, validate system functionality with stakeholders or end-users.
o	Use Cursor AI to generate test scripts to simulate user scenarios.

